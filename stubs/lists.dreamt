// Generated by: dream bindgen
// Do not edit manually.

// Erlang module: lists
extern mod lists {
    fn keyfind(arg0: any, arg1: any, arg2: any) -> any;
    fn keymember(arg0: any, arg1: any, arg2: any) -> bool;
    fn keysearch(arg0: any, arg1: any, arg2: any) -> any;
    fn member(arg0: any, arg1: any) -> bool;
    fn reverse(arg0: any, arg1: any) -> any;
    fn append(arg0: any, arg1: any) -> any;
    fn append(arg0: any) -> any;
    fn subtract(arg0: any, arg1: any) -> any;
    fn reverse(arg0: any) -> any;
    fn nth(arg0: any, arg1: any) -> any;
    fn nthtail(arg0: any, arg1: any) -> any;
    fn prefix(arg0: any, arg1: any) -> bool;
    fn suffix(arg0: any, arg1: any) -> bool;
    fn droplast(arg0: any) -> any;
    fn last(arg0: any) -> any;
    fn seq(arg0: any, arg1: any) -> any;
    fn seq(arg0: any, arg1: any, arg2: any) -> any;
    fn sum(arg0: any) -> int;
    fn duplicate(arg0: any, arg1: any) -> any;
    fn min(arg0: any) -> any;
    fn max(arg0: any) -> any;
    fn sublist(arg0: any, arg1: any, arg2: any) -> any;
    fn sublist(arg0: any, arg1: any) -> any;
    fn delete(arg0: any, arg1: any) -> any;
    fn zip(arg0: any, arg1: any) -> any;
    fn zip(arg0: any, arg1: any, arg2: any) -> any;
    fn unzip(arg0: any) -> (any, any);
    fn zip3(arg0: any, arg1: any, arg2: any) -> any;
    fn zip3(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn unzip3(arg0: any) -> (any, any, any);
    fn zipwith(arg0: any, arg1: any, arg2: any) -> any;
    fn zipwith(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn zipwith3(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn zipwith3(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any) -> any;
    fn sort(arg0: any) -> any;
    fn merge(arg0: any) -> any;
    fn merge3(arg0: any, arg1: any, arg2: any) -> any;
    fn rmerge3(arg0: [any], arg1: [any], arg2: [any]) -> [any];
    fn merge(arg0: any, arg1: any) -> any;
    fn rmerge(arg0: [any], arg1: [any]) -> [any];
    fn concat(arg0: any) -> string;
    fn flatten(arg0: any) -> any;
    fn flatten(arg0: any, arg1: any) -> any;
    fn flatlength(arg0: any) -> int;
    fn keydelete(arg0: any, arg1: any, arg2: any) -> any;
    fn keyreplace(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn keytake(arg0: any, arg1: any, arg2: any) -> any;
    fn keystore(arg0: any, arg1: any, arg2: any, arg3: any) -> any;
    fn keysort(arg0: any, arg1: any) -> any;
    fn keymerge(arg0: any, arg1: any, arg2: any) -> any;
    fn rkeymerge(arg0: int, arg1: [any], arg2: [any]) -> [any];
    fn ukeysort(arg0: any, arg1: any) -> any;
    fn ukeymerge(arg0: any, arg1: any, arg2: any) -> any;
    fn rukeymerge(arg0: int, arg1: [any], arg2: [any]) -> [any];
    fn keymap(arg0: any, arg1: any, arg2: any) -> any;
    fn enumerate(arg0: any) -> any;
    fn enumerate(arg0: any, arg1: any) -> any;
    fn enumerate(arg0: any, arg1: any, arg2: any) -> any;
    fn sort(arg0: any, arg1: any) -> any;
    fn merge(arg0: any, arg1: any, arg2: any) -> any;
    fn rmerge(arg0: fn(any, any) -> bool, arg1: [any], arg2: [any]) -> [any];
    fn usort(arg0: any, arg1: any) -> any;
    fn umerge(arg0: any, arg1: any, arg2: any) -> any;
    fn rumerge(arg0: fn(any, any) -> bool, arg1: [any], arg2: [any]) -> [any];
    fn usort(arg0: any) -> any;
    fn umerge(arg0: any) -> any;
    fn umerge3(arg0: any, arg1: any, arg2: any) -> any;
    fn rumerge3(arg0: [any], arg1: [any], arg2: [any]) -> [any];
    fn umerge(arg0: any, arg1: any) -> any;
    fn rumerge(arg0: [any], arg1: [any]) -> [any];
    fn all(arg0: any, arg1: any) -> bool;
    fn any(arg0: any, arg1: any) -> bool;
    fn map(arg0: any, arg1: any) -> any;
    fn flatmap(arg0: any, arg1: any) -> any;
    fn foldl(arg0: any, arg1: any, arg2: any) -> any;
    fn foldr(arg0: any, arg1: any, arg2: any) -> any;
    fn filter(arg0: any, arg1: any) -> any;
    fn partition(arg0: any, arg1: any) -> (any, any);
    fn filtermap(arg0: any, arg1: any) -> any;
    fn zf(arg0: fn(any) -> any, arg1: [any]) -> [any];
    fn foreach(arg0: any, arg1: any) -> any;
    fn mapfoldl(arg0: any, arg1: any, arg2: any) -> (any, any);
    fn mapfoldr(arg0: any, arg1: any, arg2: any) -> (any, any);
    fn takewhile(arg0: any, arg1: any) -> any;
    fn dropwhile(arg0: any, arg1: any) -> any;
    fn search(arg0: any, arg1: any) -> any;
    fn splitwith(arg0: any, arg1: any) -> (any, any);
    fn split(arg0: any, arg1: any) -> (any, any);
    fn join(arg0: any, arg1: any) -> any;
    fn uniq(arg0: any) -> any;
    fn uniq(arg0: any, arg1: any) -> any;
}

