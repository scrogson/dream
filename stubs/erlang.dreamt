// Generated by: dream bindgen
// Do not edit manually.

// Erlang module: erlang
extern mod erlang {
    fn adler32(data: any) -> int;
    fn adler32(oldadler: int, data: any) -> int;
    fn adler32_combine(firstadler: int, secondadler: int, secondsize: int) -> int;
    fn append_element(tuple1: any, term: any) -> any;
    fn atom_to_binary(atom_: Atom) -> any;
    fn atom_to_binary(atom_: Atom, encoding: any) -> any;
    fn atom_to_list(atom_: Atom) -> [any];
    fn binary_part(subject: any, poslen: any) -> any;
    fn binary_part(subject: any, start: int, length: int) -> any;
    fn binary_to_atom(binary_: any) -> Atom;
    fn binary_to_atom(binary_: any, encoding: any) -> Atom;
    fn binary_to_existing_atom(binary_: any) -> Atom;
    fn binary_to_existing_atom(binary_: any, encoding: any) -> Atom;
    fn binary_to_float(binary_: any) -> float;
    fn binary_to_integer(binary_: any) -> int;
    fn binary_to_integer(binary_: any, base: any) -> int;
    fn binary_to_list(binary_: any) -> [any];
    fn binary_to_list(binary_: any, start: int, stop: int) -> [any];
    fn binary_to_term(binary_: any) -> any;
    fn binary_to_term(binary_: any, opts: [any]) -> any;
    fn bit_size(bitstring: any) -> int;
    fn bitstring_to_list(bitstring: any) -> [any];
    fn bump_reductions(reductions: int) -> Atom;
    fn byte_size(bitstring: any) -> int;
    fn call_on_load_function(p1: Atom) -> any;
    fn cancel_timer(timerref: Ref) -> any;
    fn cancel_timer(timerref: Ref, options: [any]) -> any;
    fn ceil(number: any) -> int;
    fn check_old_code(module: Atom) -> bool;
    fn check_process_code(pid_: Pid, module: Atom) -> bool;
    fn check_process_code(pid_: Pid, module: Atom, optionlist: [any]) -> any;
    fn crc32(data: any) -> int;
    fn crc32(oldcrc: int, data: any) -> int;
    fn crc32_combine(firstcrc: int, secondcrc: int, secondsize: int) -> int;
    fn date() -> (int, int, int);
    fn decode_packet(type_: Atom, bin: any, options: [any]) -> any;
    fn delete_element(index: int, tuple1: any) -> any;
    fn delete_module(module: Atom) -> Option<Atom>;
    fn demonitor(monitorref: Ref) -> Atom;
    fn demonitor(monitorref: Ref, optionlist: [any]) -> bool;
    fn alias() -> Ref;
    fn alias(opts: [Atom]) -> Ref;
    fn unalias(alias: Ref) -> bool;
    fn display(term: any) -> Atom;
    fn display_string(p1: any) -> Atom;
    fn display_string(device: any, p1: [any]) -> Atom;
    fn dt_append_vm_tag_data(iodata: any) -> any;
    fn dt_get_tag() -> Option<Binary>;
    fn dt_get_tag_data() -> Option<Binary>;
    fn dt_prepend_vm_tag_data(iodata: any) -> any;
    fn dt_put_tag(iodata: any) -> Option<Binary>;
    fn dt_restore_tag(tagdata: any) -> Atom;
    fn dt_spread_tag(arg0: any) -> any;
    fn erase() -> [(any, any)];
    fn erase(key: any) -> Option<any>;
    fn error(reason: any) -> any;
    fn error(reason: any, args: any) -> any;
    fn error(reason: any, args: any, options: [(Atom, any)]) -> any;
    fn exit(reason: any) -> any;
    fn exit(pid_: any, reason: any) -> Atom;
    fn exit_signal(pid_: any, reason: any) -> Atom;
    fn external_size(term: any) -> int;
    fn external_size(term: any, options: any) -> int;
    fn finish_loading(preparedcodelist: [Ref]) -> any;
    fn finish_after_on_load(p1: Atom, p2: bool) -> Atom;
    fn float(number: any) -> float;
    fn float_to_binary(float_: float) -> any;
    fn float_to_binary(float_: float, options: [any]) -> any;
    fn float_to_list(float_: float) -> [any];
    fn float_to_list(float_: float, options: [any]) -> [any];
    fn floor(number: any) -> int;
    fn fun_info(fun: fn() -> any, item: any) -> (any, any);
    fn fun_info_mfa(fun: fn() -> any) -> (Atom, Atom, int);
    fn fun_to_list(fun: fn() -> any) -> [any];
    fn function_exported(module: Atom, function: Atom, arity: int) -> bool;
    fn garbage_collect() -> Atom;
    fn garbage_collect(pid_: Pid) -> bool;
    fn garbage_collect(pid_: Pid, optionlist: [any]) -> any;
    fn garbage_collect_message_area() -> bool;
    fn get() -> [(any, any)];
    fn get(key: any) -> Option<any>;
    fn get_keys() -> [any];
    fn get_keys(val: any) -> [any];
    fn get_module_info(module: Atom) -> [(any, any)];
    fn group_leader() -> Pid;
    fn group_leader(groupleader: Pid, pid_: Pid) -> Atom;
    fn halt() -> any;
    fn halt(status: any) -> any;
    fn halt(status: int, options: any) -> any;
    fn has_prepared_code_on_load(preparedcode: Ref) -> bool;
    fn hibernate(module: Atom, function: Atom, args: [any]) -> any;
    fn insert_element(index: int, tuple1: any, term: any) -> any;
    fn integer_to_binary(integer_: int) -> any;
    fn integer_to_list(integer_: int) -> [any];
    fn iolist_size(item: any) -> int;
    fn iolist_to_binary(iolistorbinary: any) -> any;
    fn iolist_to_iovec(iolistorbinary: any) -> [any];
    fn is_alive() -> bool;
    fn is_builtin(module: Atom, function: Atom, arity: int) -> bool;
    fn is_map_key(key: any, map_: any) -> bool;
    fn is_process_alive(pid_: Pid) -> bool;
    fn length(list_: [any]) -> int;
    fn link(pidorport: any) -> Atom;
    fn list_to_atom(string_: [any]) -> Atom;
    fn list_to_binary(iolist: [any]) -> any;
    fn list_to_bitstring(bitstringlist: [any]) -> any;
    fn list_to_existing_atom(string_: [any]) -> Atom;
    fn list_to_float(string_: [any]) -> float;
    fn list_to_integer(string_: [any]) -> int;
    fn list_to_integer(string_: [any], base: any) -> int;
    fn list_to_pid(string_: [any]) -> Pid;
    fn list_to_port(string_: [any]) -> any;
    fn list_to_ref(string_: [any]) -> Ref;
    fn list_to_tuple(list_: [any]) -> any;
    fn loaded() -> [Atom];
    fn localtime() -> ((int, int, int), (int, int, int));
    fn make_ref() -> Ref;
    fn map_size(map_: any) -> int;
    fn map_get(key: any, map_: any) -> any;
    fn match_spec_test(matchagainst: any, matchspec: any, type_: any) -> any;
    fn md5(data: any) -> any;
    fn md5_final(context: any) -> any;
    fn md5_init() -> any;
    fn md5_update(context: any, data: any) -> any;
    fn module_loaded(module: Atom) -> bool;
    fn monitor(arg0: any, arg1: any) -> Ref;
    fn monitor(arg0: any, arg1: any, arg2: [any]) -> Ref;
    fn monitor_node(node: Atom, flag: bool) -> Atom;
    fn monitor_node(node: Atom, flag: bool, options: [any]) -> Atom;
    fn nif_error(reason: any) -> any;
    fn nif_error(reason: any, args: [any]) -> any;
    fn node() -> Atom;
    fn node(arg: any) -> Atom;
    fn now() -> any;
    fn phash(term: any, range: int) -> int;
    fn phash2(term: any) -> int;
    fn phash2(term: any, range: int) -> int;
    fn pid_to_list(pid_: Pid) -> [any];
    fn port_to_list(port: any) -> [any];
    fn ports() -> [any];
    fn posixtime_to_universaltime(p1: int) -> ((int, int, int), (int, int, int));
    fn unique_integer(modifierlist: [any]) -> int;
    fn unique_integer() -> int;
    fn monotonic_time() -> int;
    fn monotonic_time(unit: any) -> int;
    fn system_time() -> int;
    fn system_time(unit: any) -> int;
    fn convert_time_unit(time: int, fromunit: any, tounit: any) -> int;
    fn time_offset() -> int;
    fn time_offset(unit: any) -> int;
    fn timestamp() -> any;
    fn prepare_loading(module: Atom, code: any) -> any;
    fn pre_loaded() -> [Atom];
    fn process_display(pid_: Pid, type_: any) -> Atom;
    fn process_flag(pid_: Pid, flag: any, value: int) -> int;
    fn process_info(pid_: Pid) -> Option<[any]>;
    fn processes() -> [Pid];
    fn purge_module(module: Atom) -> Atom;
    fn put(key: any, val: any) -> any;
    fn raise(class: Atom, reason: any, stacktrace: any) -> Atom;
    fn read_timer(timerref: Ref) -> any;
    fn read_timer(timerref: Ref, options: [(any, bool)]) -> any;
    fn ref_to_list(ref_: Ref) -> [any];
    fn register(regname: Atom, pidorport: any) -> Atom;
    fn registered() -> [Atom];
    fn resume_process(suspendee: Pid) -> Atom;
    fn round(number: any) -> int;
    fn self() -> Pid;
    fn send_after(time: int, dest: any, msg: any) -> Ref;
    fn send_after(time: int, dest: any, msg: any, options: [(any, bool)]) -> Ref;
    fn seq_trace(p1: Atom, p2: any) -> any;
    fn seq_trace_print(p1: any) -> bool;
    fn seq_trace_print(p1: any, p2: any) -> bool;
    fn setnode(p1: Atom, p2: int) -> Atom;
    fn setnode(node: Atom, distctrlr: any, opts: (int, int)) -> Atom;
    fn size(item: any) -> int;
    fn spawn(module: Atom, function: Atom, args: [any]) -> Pid;
    fn spawn_link(module: Atom, function: Atom, args: [any]) -> Pid;
    fn split_binary(bin: any, pos: int) -> (any, any);
    fn start_timer(time: int, dest: any, msg: any) -> Ref;
    fn start_timer(time: int, dest: any, msg: any, options: [(any, bool)]) -> Ref;
    fn suspend_process(suspendee: Pid, optlist: [any]) -> bool;
    fn suspend_process(suspendee: Pid) -> Atom;
    fn system_monitor() -> Option<(any, any)>;
    fn system_monitor(arg: Option<(any, any)>) -> Option<(any, any)>;
    fn system_monitor(monitorpid: Pid, options: [any]) -> Option<(any, any)>;
    fn system_profile() -> Option<(any, any)>;
    fn system_profile(profilerpid: any, options: [Atom]) -> Option<(any, [any])>;
    fn throw(any: any) -> any;
    fn time() -> (int, int, int);
    fn trace(pidportspec: any, how: bool, flaglist: [any]) -> int;
    fn trace_delivered(tracee: any) -> Ref;
    fn trace_info(pidportfuncevent: any, item: any) -> any;
    fn trunc(number: any) -> int;
    fn tuple_size(tuple_: any) -> int;
    fn universaltime() -> ((int, int, int), (int, int, int));
    fn universaltime_to_posixtime(p1: ((int, int, int), (int, int, int))) -> int;
    fn unlink(id: any) -> Atom;
    fn unregister(regname: Atom) -> Atom;
    fn whereis(regname: Atom) -> any;
    fn abs(float_: int) -> float;
    fn append(list_: [any], tail: any) -> [any];
    fn element(n: int, tuple_: any) -> any;
    fn get_module_info(module: Atom, item: any) -> any;
    fn hd(list_: [any]) -> any;
    fn is_atom(term: any) -> bool;
    fn is_binary(term: any) -> bool;
    fn is_bitstring(term: any) -> bool;
    fn is_boolean(term: any) -> bool;
    fn is_float(term: any) -> bool;
    fn is_function(term: any) -> bool;
    fn is_function(term: any, arity: int) -> bool;
    fn is_integer(term: any) -> bool;
    fn is_list(term: any) -> bool;
    fn is_number(term: any) -> bool;
    fn is_pid(term: any) -> bool;
    fn is_map(term: any) -> bool;
    fn is_port(term: any) -> bool;
    fn is_record(term: any, recordtag: Atom) -> bool;
    fn is_record(term: any, recordtag: Atom, size: int) -> bool;
    fn is_reference(term: any) -> bool;
    fn is_tuple(term: any) -> bool;
    fn load_module(module: Atom, binary_: any) -> Result<any, any>;
    fn load_nif(path: [any], loadinfo: any) -> any;
    fn localtime_to_universaltime(localtime: ((int, int, int), (int, int, int)), isdst: any) -> ((int, int, int), (int, int, int));
    fn make_fun(module: Atom, function: Atom, arity: int) -> fn() -> any;
    fn make_tuple(arity: int, initialvalue: any) -> any;
    fn make_tuple(arity: int, defaultvalue: any, initlist: any) -> any;
    fn open_port(portname: any, portsettings: [any]) -> any;
    fn process_flag(arg0: any, boolean: bool) -> bool;
    fn process_info(pid_: Pid, item: any) -> any;
    fn send(dest: any, msg: any) -> any;
    fn send(dest: any, msg: any, options: [any]) -> any;
    fn seq_trace_info(arg0: any) -> any;
    fn setelement(index: int, tuple1: any, value: any) -> any;
    fn statistics(arg0: any) -> [int];
    fn subtract(arg0: [any], arg1: [any]) -> [any];
    fn system_flag(arg0: any, depth: int) -> Option<any>;
    fn term_to_binary(term: any) -> any;
    fn term_to_binary(term: any, options: any) -> any;
    fn term_to_iovec(term: any) -> [any];
    fn term_to_iovec(term: any, options: any) -> [any];
    fn tl(list_: [any]) -> any;
    fn trace_pattern(mfa: any, matchspec: any) -> int;
    fn trace_pattern(arg0: any, matchspec: any, arg2: [any]) -> int;
    fn tuple_to_list(tuple_: any) -> [any];
    fn system_info(arg0: any) -> (Option<any>, [int], [Atom], any);
    fn universaltime_to_localtime(universaltime: ((int, int, int), (int, int, int))) -> ((int, int, int), (int, int, int));
    fn apply(fun: fn() -> any, args: [any]) -> any;
    fn apply(module: Atom, function: Atom, args: [any]) -> any;
    fn spawn(fun: fn() -> any) -> Pid;
    fn spawn(node: Atom, fun: fn() -> any) -> Pid;
    fn spawn_link(fun: fn() -> any) -> Pid;
    fn spawn_link(node: Atom, fun: fn() -> any) -> Pid;
    fn spawn_monitor(fun: fn() -> any) -> (pid, ref);
    fn spawn_monitor(node: Atom, fun: fn() -> any) -> (pid, ref);
    fn spawn_monitor(module: Atom, function: Atom, args: [any]) -> (pid, ref);
    fn spawn_opt(fun: fn() -> any, options: [any]) -> any;
    fn spawn_opt(node: Atom, fun: fn() -> any, options: [any]) -> any;
    fn spawn(node: Atom, module: Atom, function: Atom, args: [any]) -> Pid;
    fn spawn_link(node: Atom, module: Atom, function: Atom, args: [any]) -> Pid;
    fn spawn_monitor(node: Atom, module: Atom, function: Atom, args: [any]) -> (pid, ref);
    fn spawn_opt(module: Atom, function: Atom, args: [any], options: [any]) -> any;
    fn spawn_opt(node: Atom, module: Atom, function: Atom, args: [any], options: [any]) -> any;
    fn spawn_request(fun: fn() -> any) -> Ref;
    fn spawn_request(fun: fn() -> any, options: [any]) -> Ref;
    fn spawn_request(node: Atom, fun: fn() -> any, options: [any]) -> Ref;
    fn spawn_request(node: Atom, module: Atom, function: Atom, args: [any]) -> Ref;
    fn spawn_request(node: Atom, module: Atom, function: Atom, args: [any], options: [any]) -> Ref;
    fn spawn_request_abandon(reqid: any) -> bool;
    fn yield() -> Atom;
    fn nodes() -> [Atom];
    fn nodes(arg: any) -> [Atom];
    fn nodes(arg: any, infoopts: any) -> [(Atom, any)];
    fn disconnect_node(node: Atom) -> any;
    fn fun_info(fun: fn() -> any) -> [(any, any)];
    fn send_nosuspend(dest: any, msg: any) -> bool;
    fn send_nosuspend(dest: any, msg: any, options: [any]) -> bool;
    fn localtime_to_universaltime(localtime: ((int, int, int), (int, int, int))) -> ((int, int, int), (int, int, int));
    fn port_command(port: any, data: any) -> Atom;
    fn port_command(port: any, data: any, optionlist: [any]) -> bool;
    fn port_connect(port: any, pid_: Pid) -> Atom;
    fn port_close(port: any) -> Atom;
    fn port_control(port: any, operation: int, data: any) -> any;
    fn port_call(port: any, data: any) -> any;
    fn port_call(port: any, operation: int, data: any) -> any;
    fn port_info(port: any) -> Option<[any]>;
    fn port_info(port: any, arg1: any) -> Option<(any, any)>;
    fn port_set_data(port: any, data: any) -> Atom;
    fn port_get_data(port: any) -> any;
    fn dist_ctrl_input_handler(dhandle: Atom, inputhandler: Pid) -> Atom;
    fn dist_ctrl_put_data(dhandle: Atom, data: any) -> Atom;
    fn dist_ctrl_get_data(dhandle: Atom) -> any;
    fn dist_ctrl_get_data_notification(dhandle: Atom) -> Atom;
    fn dist_ctrl_set_opt(dhandle: Atom, arg1: Atom, value: bool) -> bool;
    fn dist_ctrl_get_opt(dhandle: Atom, arg1: Atom) -> bool;
    fn dist_get_stat(dhandle: Atom) -> (Atom, int, int, int);
    fn delay_trap(result: any, arg1: any) -> any;
    fn set_cookie(cookie: Atom) -> Atom;
    fn set_cookie(node: Atom, cookie: Atom) -> Atom;
    fn get_cookie() -> any;
    fn get_cookie(node: Atom) -> any;
    fn integer_to_list(integer_: int, base: any) -> [any];
    fn integer_to_binary(integer_: int, base: any) -> any;
    fn min(term1: any, term2: any) -> any;
    fn max(term1: any, term2: any) -> any;
    fn memory() -> [(Atom, int)];
    fn memory(type_: [Atom]) -> [(Atom, int)];
    fn gather_gc_info_result(ref_: Ref) -> (any, any, any);
}

