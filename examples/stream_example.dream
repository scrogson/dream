// Stream Example - Demonstrates lazy evaluation

mod stream_example {
    use io::{println, format};

    pub fn main() -> atom {
        println("=== Stream Example ===");
        println("");

        // Create an infinite stream of numbers starting from 1
        println("1. Infinite sequence with take:");
        let nums = stream::from(1);
        let first_five = stream::take(nums, 5);
        let result = stream::to_list(first_five);
        format("   stream::from(1) |> take(5) = ~p~n", [result]);
        println("");

        // iterate: generate powers of 2
        println("2. Powers of 2 (iterate):");
        let powers = stream::iterate(1, |x| { x * 2 });
        let first_eight = stream::take(powers, 8);
        format("   iterate(1, |x| x*2) |> take(8) = ~p~n", [stream::to_list(first_eight)]);
        println("");

        // map and filter
        println("3. Map and filter (squares of evens):");
        let squares_of_evens = stream::from(1)
            |> stream::filter(|x| { x % 2 == 0 })
            |> stream::map(|x| { x * x })
            |> stream::take(5);
        format("   evens |> square |> take(5) = ~p~n", [stream::to_list(squares_of_evens)]);
        println("");

        // range
        println("4. Range:");
        let r = stream::range(1, 6);
        format("   range(1, 6) = ~p~n", [stream::to_list(r)]);
        println("");

        // cycle
        println("5. Cycle through list:");
        let cycled = stream::cycle([:a, :b, :c])
            |> stream::take(7);
        format("   cycle([:a, :b, :c]) |> take(7) = ~p~n", [stream::to_list(cycled)]);
        println("");

        // duplicate
        println("6. Duplicate:");
        let dups = stream::duplicate(:hello, 3);
        format("   duplicate(:hello, 3) = ~p~n", [stream::to_list(dups)]);
        println("");

        // zip
        println("7. Zip two streams:");
        let letters = stream::from_list([:a, :b, :c]);
        let numbers = stream::from(1);
        let zipped = stream::zip(letters, numbers);
        format("   zip([:a,:b,:c], [1..]) = ~p~n", [stream::to_list(zipped)]);
        println("");

        // fold/reduce
        println("8. Sum with fold:");
        let total = stream::range(1, 11)
            |> stream::fold(0, |acc, x| { acc + x });
        format("   sum(1..10) = ~p~n", [total]);
        println("");

        // take_while
        println("9. Take while:");
        let small = stream::from(1)
            |> stream::take_while(|x| { x < 10 });
        format("   from(1) |> take_while(< 10) = ~p~n", [stream::to_list(small)]);
        println("");

        // Lazy evaluation - only computes what's needed
        println("10. Lazy evaluation demo:");
        println("    Creating infinite stream, only taking 3...");
        let lazy = stream::iterate(0, |x| {
            // This would loop forever if eager
            x + 1
        });
        let three = stream::take(lazy, 3);
        format("    Result: ~p~n", [stream::to_list(three)]);
        println("");

        // concat
        println("11. Concatenate streams:");
        let s1 = stream::from_list([1, 2, 3]);
        let s2 = stream::from_list([4, 5, 6]);
        let combined = stream::concat(s1, s2);
        format("    [1,2,3] ++ [4,5,6] = ~p~n", [stream::to_list(combined)]);
        println("");

        // any/all
        println("12. Any/All predicates:");
        let has_even = stream::range(1, 10)
            |> stream::any(|x| { x % 2 == 0 });
        format("    any even in 1..9? ~p~n", [has_even]);

        let all_positive = stream::range(1, 10)
            |> stream::all(|x| { x > 0 });
        format("    all positive in 1..9? ~p~n", [all_positive]);
        println("");

        println("Done!");
        :ok
    }
}
