// Erlang gb_trees module bindings
//
// General balanced trees (key-value store).
// See: https://www.erlang.org/doc/man/gb_trees.html

#[name = "gb_trees"]
extern mod gb_trees {
    /// Create an empty tree.
    fn empty() -> any;

    /// Check if a key is present.
    fn is_defined(key: any, tree: any) -> bool;

    /// Check if tree is empty.
    fn is_empty(tree: any) -> bool;

    /// Get the number of nodes.
    fn size(tree: any) -> int;

    /// Look up a key, return value or crash.
    fn get(key: any, tree: any) -> any;

    /// Look up a key, return {value, Value} or none.
    fn lookup(key: any, tree: any) -> any;

    /// Insert a new key-value, crash if key exists.
    fn insert(key: any, value: any, tree: any) -> any;

    /// Insert or update a key-value.
    fn enter(key: any, value: any, tree: any) -> any;

    /// Update an existing key, crash if not found.
    fn update(key: any, value: any, tree: any) -> any;

    /// Delete a key, crash if not found.
    fn delete(key: any, tree: any) -> any;

    /// Delete a key if it exists.
    fn delete_any(key: any, tree: any) -> any;

    /// Take a key-value from tree.
    fn take(key: any, tree: any) -> (any, any);

    /// Take a key-value from tree, return error if not found.
    fn take_any(key: any, tree: any) -> any;

    /// Get the smallest key.
    fn smallest(tree: any) -> (any, any);

    /// Get the largest key.
    fn largest(tree: any) -> (any, any);

    /// Take the smallest key-value.
    fn take_smallest(tree: any) -> (any, any, any);

    /// Take the largest key-value.
    fn take_largest(tree: any) -> (any, any, any);

    /// Get all keys in order.
    fn keys(tree: any) -> [any];

    /// Get all values (in key order).
    fn values(tree: any) -> [any];

    /// Convert to ordered list of {Key, Value}.
    fn to_list(tree: any) -> [(any, any)];

    /// Create tree from ordered list.
    fn from_orddict(list: [(any, any)]) -> any;

    /// Create balanced tree from ordered list.
    fn balance(tree: any) -> any;

    /// Get an iterator (start).
    fn iterator(tree: any) -> any;

    /// Get an iterator from a specific key.
    fn iterator_from(key: any, tree: any) -> any;

    /// Get next from iterator.
    fn next(iter: any) -> any;

    /// Map a function over values.
    fn map(fun: fn(any, any) -> any, tree: any) -> any;
}
