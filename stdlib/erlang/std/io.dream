// Erlang io module bindings
//
// Input/output operations from the Erlang standard library.
// See: https://www.erlang.org/doc/man/io.html

#[name = "io"]
extern mod io {
    // ============== Output ==============

    /// Write a formatted string to standard output.
    fn format(format: any, args: [any]) -> atom;

    /// Write a formatted string to a device.
    fn format(device: any, format: any, args: [any]) -> atom;

    /// Write formatted output and return result.
    fn fwrite(format: any, args: [any]) -> Result<atom, any>;

    /// Write formatted output to a device and return result.
    fn fwrite(device: any, format: any, args: [any]) -> Result<atom, any>;

    /// Write a term to standard output.
    fn put_chars(chars: any) -> atom;

    /// Write a term to a device.
    fn put_chars(device: any, chars: any) -> atom;

    /// Write a newline.
    fn nl() -> atom;

    /// Write a newline to a device.
    fn nl(device: any) -> atom;

    // ============== Input ==============

    /// Read a line from standard input.
    fn get_line(prompt: any) -> any;

    /// Read a line from a device.
    fn get_line(device: any, prompt: any) -> any;

    /// Read characters from standard input.
    fn get_chars(prompt: any, count: int) -> any;

    /// Read characters from a device.
    fn get_chars(device: any, prompt: any, count: int) -> any;

    /// Read and parse Erlang terms.
    fn read(prompt: any) -> any;

    /// Read and parse Erlang terms from a device.
    fn read(device: any, prompt: any) -> any;

    /// Scan input according to format.
    fn fread(prompt: any, format: any) -> any;

    /// Scan input from device according to format.
    fn fread(device: any, prompt: any, format: any) -> any;

    // ============== Device Management ==============

    /// Get the current column position.
    fn columns() -> Result<int, atom>;

    /// Get the column position for a device.
    fn columns(device: any) -> Result<int, atom>;

    /// Get the number of rows.
    fn rows() -> Result<int, atom>;

    /// Get the number of rows for a device.
    fn rows(device: any) -> Result<int, atom>;

    /// Check if device supports ANSI escape codes.
    fn getopts(device: any) -> [any];

    /// Set device options.
    fn setopts(opts: [any]) -> Result<atom, any>;

    /// Set device options for a specific device.
    fn setopts(device: any, opts: [any]) -> Result<atom, any>;

    // ============== Requests ==============

    /// Send a request to the I/O server.
    fn request(request: any) -> any;

    /// Send a request to a specific I/O server.
    fn request(device: any, request: any) -> any;

    /// Parse control sequences in a format string.
    fn scan_erl_form(prompt: any) -> any;

    /// Parse control sequences from a device.
    fn scan_erl_form(device: any, prompt: any) -> any;
}
