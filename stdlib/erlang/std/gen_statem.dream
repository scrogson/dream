// Erlang gen_statem module bindings
//
// Generic state machine behavior from OTP.
// See: https://www.erlang.org/doc/man/gen_statem.html

#[name = "gen_statem"]
extern mod gen_statem {
    // ============== Starting ==============

    /// Start a linked state machine.
    fn start_link(module: atom, args: any, opts: [any]) -> Result<pid, any>;

    /// Start a linked state machine with registered name.
    fn start_link(name: any, module: atom, args: any, opts: [any]) -> Result<pid, any>;

    /// Start an unlinked state machine.
    fn start(module: atom, args: any, opts: [any]) -> Result<pid, any>;

    /// Start an unlinked state machine with registered name.
    fn start(name: any, module: atom, args: any, opts: [any]) -> Result<pid, any>;

    /// Start a monitored state machine.
    fn start_monitor(module: atom, args: any, opts: [any]) -> Result<(pid, ref), any>;

    /// Start a monitored state machine with registered name.
    fn start_monitor(name: any, module: atom, args: any, opts: [any]) -> Result<(pid, ref), any>;

    // ============== Synchronous Calls ==============

    /// Make a synchronous call.
    fn call(server: any, request: any) -> any;

    /// Make a synchronous call with timeout.
    fn call(server: any, request: any, timeout: any) -> any;

    // ============== Asynchronous Casts ==============

    /// Send an asynchronous event.
    fn cast(server: any, msg: any) -> atom;

    // ============== Replies ==============

    /// Send a reply from a callback.
    fn reply(replies: [any]) -> atom;

    /// Send a single reply.
    fn reply(from: any, reply: any) -> atom;

    // ============== Stopping ==============

    /// Stop a state machine.
    fn stop(server: any) -> atom;

    /// Stop with a reason.
    fn stop(server: any, reason: any) -> atom;

    /// Stop with reason and timeout.
    fn stop(server: any, reason: any, timeout: any) -> atom;

    // ============== Request Handling ==============

    /// Send a request and get request ID.
    fn send_request(server: any, request: any) -> any;

    /// Wait for response.
    fn wait_response(request_id: any, timeout: any) -> any;

    /// Check if message is a response.
    fn check_response(msg: any, request_id: any) -> any;

    /// Receive a response.
    fn receive_response(request_id: any, timeout: any) -> any;

    // ============== Request ID Collections ==============

    /// Create new request ID collection.
    fn reqids_new() -> any;

    /// Add request ID to collection.
    fn reqids_add(request_id: any, label: any, collection: any) -> any;

    /// Get collection size.
    fn reqids_size(collection: any) -> int;

    /// Convert collection to list.
    fn reqids_to_list(collection: any) -> [any];
}
