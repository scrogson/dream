// Dream Standard Library - Stream Module
//
// Lazy sequences that compute values on demand.
// Streams are composable and can represent infinite sequences.
//
// A stream is a tuple: (:stream, next_fn, state)
// - next_fn(state) returns (:cont, value, new_state) or :done
//
// Example:
//   stream::iterate(1, |x| { x * 2 })
//   |> stream::take(5)
//   |> stream::to_list()
//   // => [1, 2, 4, 8, 16]

// ============== Stream Creation ==============

/// Create a stream that generates values by repeatedly applying a function.
/// Starts with `start`, then yields fun(start), fun(fun(start)), etc.
pub fn iterate(start: any, fun: any) -> (atom, any, any) {
    let next_fn = |state| {
        let next_state = :erlang::apply(fun, [state]);
        (:cont, state, next_state)
    };
    (:stream, next_fn, start)
}

/// Create a stream that repeatedly calls a function.
/// Each call to the function produces the next value.
pub fn repeatedly(fun: any) -> (atom, any, any) {
    let next_fn = |state| {
        let value = :erlang::apply(fun, []);
        (:cont, value, state)
    };
    (:stream, next_fn, ())
}

/// Create a stream that cycles through a list infinitely.
pub fn cycle(items: [any]) -> (atom, any, any) {
    let next_fn = |state| {
        match state {
            [] => {
                // Restart from beginning
                match items {
                    [] => :done,
                    [head | tail] => (:cont, head, tail)
                }
            },
            [head | tail] => (:cont, head, tail)
        }
    };
    (:stream, next_fn, items)
}

/// Create a stream from a generator function with accumulator.
/// fun(acc) should return (:cont, value, new_acc) or :done.
pub fn unfold(initial_acc: any, fun: any) -> (atom, any, any) {
    let next_fn = |state| {
        :erlang::apply(fun, [state])
    };
    (:stream, next_fn, initial_acc)
}

/// Convert a list to a stream.
pub fn from_list(items: [any]) -> (atom, any, any) {
    let next_fn = |state| {
        match state {
            [] => :done,
            [head | tail] => (:cont, head, tail)
        }
    };
    (:stream, next_fn, items)
}

/// Create a stream of integers from start to infinity.
pub fn from(start: int) -> (atom, any, any) {
    iterate(start, |n| { n + 1 })
}

/// Create a stream of integers in a range [start, stop).
pub fn range(start: int, stop: int) -> (atom, any, any) {
    let next_fn = |state| {
        match state < stop {
            :true => (:cont, state, state + 1),
            :false => :done
        }
    };
    (:stream, next_fn, start)
}

/// Create a stream that duplicates a value n times.
pub fn duplicate(value: any, n: int) -> (atom, any, any) {
    let next_fn = |count| {
        match count > 0 {
            :true => (:cont, value, count - 1),
            :false => :done
        }
    };
    (:stream, next_fn, n)
}

// ============== Stream Transformations ==============

/// Apply a function to each element of the stream.
pub fn map(s: (atom, any, any), fun: any) -> (atom, any, any) {
    let (:stream, inner_next, inner_state) = s;
    let next_fn = |state| {
        let (next, st) = state;
        match :erlang::apply(next, [st]) {
            (:cont, value, new_st) => {
                let mapped = :erlang::apply(fun, [value]);
                (:cont, mapped, (next, new_st))
            },
            :done => :done
        }
    };
    (:stream, next_fn, (inner_next, inner_state))
}

/// Keep only elements where predicate returns true.
pub fn filter(s: (atom, any, any), pred: any) -> (atom, any, any) {
    let (:stream, inner_next, inner_state) = s;
    let next_fn = |state| {
        filter_next(state, pred)
    };
    (:stream, next_fn, (inner_next, inner_state))
}

fn filter_next(state: any, pred: any) -> any {
    let (next, st) = state;
    match :erlang::apply(next, [st]) {
        (:cont, value, new_st) => {
            match :erlang::apply(pred, [value]) {
                :true => (:cont, value, (next, new_st)),
                :false => filter_next((next, new_st), pred)
            }
        },
        :done => :done
    }
}

/// Take the first n elements from the stream.
pub fn take(s: (atom, any, any), n: int) -> (atom, any, any) {
    let (:stream, inner_next, inner_state) = s;
    let next_fn = |state| {
        let (next, st, remaining) = state;
        match remaining > 0 {
            :true => {
                match :erlang::apply(next, [st]) {
                    (:cont, value, new_st) => (:cont, value, (next, new_st, remaining - 1)),
                    :done => :done
                }
            },
            :false => :done
        }
    };
    (:stream, next_fn, (inner_next, inner_state, n))
}

/// Drop the first n elements from the stream.
pub fn drop(s: (atom, any, any), n: int) -> (atom, any, any) {
    let (:stream, inner_next, inner_state) = s;
    // Skip n elements upfront
    let skipped_state = skip_n(inner_next, inner_state, n);
    (:stream, inner_next, skipped_state)
}

fn skip_n(next: any, state: any, n: int) -> any {
    match n > 0 {
        :true => {
            match :erlang::apply(next, [state]) {
                (:cont, _value, new_state) => skip_n(next, new_state, n - 1),
                :done => state
            }
        },
        :false => state
    }
}

/// Take elements while predicate returns true.
pub fn take_while(s: (atom, any, any), pred: any) -> (atom, any, any) {
    let (:stream, inner_next, inner_state) = s;
    let next_fn = |state| {
        let (next, st, done) = state;
        match done {
            :true => :done,
            :false => {
                match :erlang::apply(next, [st]) {
                    (:cont, value, new_st) => {
                        match :erlang::apply(pred, [value]) {
                            :true => (:cont, value, (next, new_st, :false)),
                            :false => :done
                        }
                    },
                    :done => :done
                }
            }
        }
    };
    (:stream, next_fn, (inner_next, inner_state, :false))
}

/// Drop elements while predicate returns true.
pub fn drop_while(s: (atom, any, any), pred: any) -> (atom, any, any) {
    let (:stream, inner_next, inner_state) = s;
    // Skip while predicate is true
    let skipped_state = skip_while(inner_next, inner_state, pred);
    (:stream, inner_next, skipped_state)
}

fn skip_while(next: any, state: any, pred: any) -> any {
    match :erlang::apply(next, [state]) {
        (:cont, value, new_state) => {
            match :erlang::apply(pred, [value]) {
                :true => skip_while(next, new_state, pred),
                :false => state
            }
        },
        :done => state
    }
}

/// Zip two streams together into pairs.
pub fn zip(s1: (atom, any, any), s2: (atom, any, any)) -> (atom, any, any) {
    let (:stream, next1, state1) = s1;
    let (:stream, next2, state2) = s2;
    let next_fn = |state| {
        let (n1, st1, n2, st2) = state;
        match :erlang::apply(n1, [st1]) {
            (:cont, v1, new_st1) => {
                match :erlang::apply(n2, [st2]) {
                    (:cont, v2, new_st2) => (:cont, (v1, v2), (n1, new_st1, n2, new_st2)),
                    :done => :done
                }
            },
            :done => :done
        }
    };
    (:stream, next_fn, (next1, state1, next2, state2))
}

/// Concatenate two streams.
pub fn concat(s1: (atom, any, any), s2: (atom, any, any)) -> (atom, any, any) {
    let (:stream, next1, state1) = s1;
    let (:stream, next2, state2) = s2;
    let next_fn = |state| {
        match state {
            (:first, n1, st1, n2, st2) => {
                match :erlang::apply(n1, [st1]) {
                    (:cont, value, new_st1) => (:cont, value, (:first, n1, new_st1, n2, st2)),
                    :done => {
                        // Switch to second stream
                        match :erlang::apply(n2, [st2]) {
                            (:cont, value, new_st2) => (:cont, value, (:second, n2, new_st2)),
                            :done => :done
                        }
                    }
                }
            },
            (:second, n2, st2) => {
                match :erlang::apply(n2, [st2]) {
                    (:cont, value, new_st2) => (:cont, value, (:second, n2, new_st2)),
                    :done => :done
                }
            }
        }
    };
    (:stream, next_fn, (:first, next1, state1, next2, state2))
}

/// Flatten a stream of streams into a single stream.
pub fn flat_map(s: (atom, any, any), fun: any) -> (atom, any, any) {
    let (:stream, inner_next, inner_state) = s;
    let next_fn = |state| {
        flat_map_next(state, fun)
    };
    (:stream, next_fn, (:outer, inner_next, inner_state, :none))
}

fn flat_map_next(state: any, fun: any) -> any {
    match state {
        (:outer, outer_next, outer_st, :none) => {
            // Get next element from outer stream
            match :erlang::apply(outer_next, [outer_st]) {
                (:cont, value, new_outer_st) => {
                    // Apply function to get inner stream
                    let (:stream, inner_next, inner_st) = :erlang::apply(fun, [value]);
                    flat_map_next((:inner, outer_next, new_outer_st, inner_next, inner_st), fun)
                },
                :done => :done
            }
        },
        (:inner, outer_next, outer_st, inner_next, inner_st) => {
            match :erlang::apply(inner_next, [inner_st]) {
                (:cont, value, new_inner_st) => {
                    (:cont, value, (:inner, outer_next, outer_st, inner_next, new_inner_st))
                },
                :done => {
                    // Inner stream exhausted, get next from outer
                    flat_map_next((:outer, outer_next, outer_st, :none), fun)
                }
            }
        }
    }
}

// ============== Stream Consumption ==============

/// Convert stream to a list.
/// WARNING: Don't use on infinite streams!
pub fn to_list(s: (atom, any, any)) -> [any] {
    let (:stream, next, state) = s;
    to_list_acc(next, state, [])
}

fn to_list_acc(next: any, state: any, acc: [any]) -> [any] {
    match :erlang::apply(next, [state]) {
        (:cont, value, new_state) => to_list_acc(next, new_state, :lists::append(acc, [value])),
        :done => acc
    }
}

/// Fold/reduce over a stream.
pub fn fold(s: (atom, any, any), acc: any, fun: any) -> any {
    let (:stream, next, state) = s;
    fold_acc(next, state, acc, fun)
}

fn fold_acc(next: any, state: any, acc: any, fun: any) -> any {
    match :erlang::apply(next, [state]) {
        (:cont, value, new_state) => {
            let new_acc = :erlang::apply(fun, [acc, value]);
            fold_acc(next, new_state, new_acc, fun)
        },
        :done => acc
    }
}

/// Run the stream for side effects, discarding values.
pub fn run(s: (atom, any, any)) -> atom {
    let (:stream, next, state) = s;
    run_loop(next, state)
}

fn run_loop(next: any, state: any) -> atom {
    match :erlang::apply(next, [state]) {
        (:cont, _value, new_state) => run_loop(next, new_state),
        :done => :ok
    }
}

/// Run the stream, calling a function for each element.
pub fn each(s: (atom, any, any), fun: any) -> atom {
    let (:stream, next, state) = s;
    each_loop(next, state, fun)
}

fn each_loop(next: any, state: any, fun: any) -> atom {
    match :erlang::apply(next, [state]) {
        (:cont, value, new_state) => {
            :erlang::apply(fun, [value]);
            each_loop(next, new_state, fun)
        },
        :done => :ok
    }
}

/// Get the first element of the stream.
pub fn first(s: (atom, any, any)) -> any {
    let (:stream, next, state) = s;
    match :erlang::apply(next, [state]) {
        (:cont, value, _new_state) => (:ok, value),
        :done => :error
    }
}

/// Count elements in the stream.
/// WARNING: Don't use on infinite streams!
pub fn count(s: (atom, any, any)) -> int {
    fold(s, 0, |acc, _x| { acc + 1 })
}

/// Sum elements in the stream.
pub fn sum(s: (atom, any, any)) -> int {
    fold(s, 0, |acc, x| { acc + x })
}

/// Check if any element matches predicate.
pub fn any(s: (atom, any, any), pred: any) -> atom {
    let (:stream, next, state) = s;
    any_loop(next, state, pred)
}

fn any_loop(next: any, state: any, pred: any) -> atom {
    match :erlang::apply(next, [state]) {
        (:cont, value, new_state) => {
            match :erlang::apply(pred, [value]) {
                :true => :true,
                :false => any_loop(next, new_state, pred)
            }
        },
        :done => :false
    }
}

/// Check if all elements match predicate.
pub fn all(s: (atom, any, any), pred: any) -> atom {
    let (:stream, next, state) = s;
    all_loop(next, state, pred)
}

fn all_loop(next: any, state: any, pred: any) -> atom {
    match :erlang::apply(next, [state]) {
        (:cont, value, new_state) => {
            match :erlang::apply(pred, [value]) {
                :true => all_loop(next, new_state, pred),
                :false => :false
            }
        },
        :done => :true
    }
}
